class ApplicationController < ActionController::Base
  # Authentication methods generated by authentication generator
  before_action :set_current_request_details
  before_action :restore_validator_context

  helper_method :current_user, :user_signed_in?, :unread_notifications_count
  # Authentication public methods generated end

  # Only allow modern browsers supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has.
  # TEMPORARILY DISABLED FOR DEBUGGING
  # allow_browser versions: :modern

  include FriendlyErrorHandlingConcern
  include DevelopmentCsrfBypassConcern
  include TurboCompatibleRenderConcern


  # Authentication private methods begin
  private

  def current_user
    Current.session&.user
  end

  def user_signed_in?
    current_user.present?
  end

  def unread_notifications_count
    return 0 unless current_user
    current_user.notifications.unread.count
  end

  def authenticate_user!
    if session_record = find_session_record
      Current.session = session_record
    else
      redirect_to sign_in_path
    end
  end

  alias_method :authenticate, :authenticate_user!

  def set_current_request_details
    Current.user_agent = request.user_agent
    Current.ip_address = request.ip

    if session_record = find_session_record
      Current.session = session_record
    else
      # Auto-login default user if no session exists
      auto_login_default_user
    end
  end
  
  # 恢复验证器执行上下文（设置 data_version）
  # 
  # 多会话支持流程：
  # 1. APK 通过 Deeplink 传递 session_id: ai.clacky.trip01://?session_id=xxx
  # 2. ValidatorSessionBinder 中间件提取并存储到独立 cookie: validator_session_id
  # 3. 此方法优先使用 cookie 中的 session_id，确保用户明确知道操作的会话
  # 4. 如果未绑定，回退到最新活跃会话（兼容单会话模式）
  # 
  # WHY COOKIE INSTEAD OF RAILS SESSION?
  # - Rails session is shared across all tabs → multi-tab validation fails
  # - Independent cookie allows each tab to maintain its own session_id
  def restore_validator_context
    return unless user_signed_in?
    
    begin
      execution = nil
      
      # 优先级 1: 从独立 cookie 读取绑定的会话 ID（APK Deeplink 传参）
      cookie_session_id = cookies['validator_session_id']
      if cookie_session_id.present?
        execution = ValidatorExecution.find_by(
          execution_id: cookie_session_id,
          user_id: current_user.id
        )
        
        if execution
          Rails.logger.info "[Validator Context] Using bound session from cookie: #{execution.execution_id}"
        else
          Rails.logger.warn "[Validator Context] Bound session not found: #{cookie_session_id}, falling back to latest active session"
          cookies.delete('validator_session_id')  # 清理无效的 session_id
        end
      end
      
      # 优先级 2: 查找最新活跃会话（兼容旧行为，单会话模式）
      unless execution
        execution = ValidatorExecution.active_for_user(current_user.id).first
        if execution
          Rails.logger.info "[Validator Context] Using latest active session: #{execution.execution_id}"
        end
      end
      
      return unless execution
      
      # 获取 data_version
      data_version = execution.data_version
      return unless data_version
      
      # 设置 PostgreSQL 会话变量（请求级别）
      # ⚠️ 必须每次请求都设置，因为 Rails 连接池会复用连接
      # 如果不在每个请求重新设置，不同 session_id 会共享同一个连接的 data_version
      # 导致会话隔离失败！
      # 
      # 这里使用普通的 SET（等同于 SET SESSION），但通过 before_action 确保每次请求都执行
      # 这样即使连接被复用，data_version 也会被正确更新
      ActiveRecord::Base.connection.execute("SET app.data_version = '#{data_version}'")
      
      Rails.logger.debug "[Validator Context] Restored data_version=#{data_version} for user #{current_user.id} (execution #{execution.execution_id})"
    rescue StandardError => e
      Rails.logger.error "[Validator Context] Failed to restore: #{e.message}"
    end
  end

  def auto_login_default_user
    default_email = 'demo@travel01.com'
    default_password = 'password123'
    
    # Find or create default user
    user = User.find_by(email: default_email)
    
    unless user
      user = User.create!(
        email: default_email,
        password: default_password,
        password_confirmation: default_password,
        verified: true
      )
    end
    
    # Create session for default user
    session_record = user.sessions.create!(
      user_agent: Current.user_agent,
      ip_address: Current.ip_address
    )
    
    # Set session cookie
    cookies.signed.permanent[:session_token] = { value: session_record.id, httponly: true, same_site: :lax }
    
    # Set current session
    Current.session = session_record
  rescue => e
    Rails.logger.error "Failed to auto-login default user: #{e.message}"
    nil
  end

  def find_session_record
    # Try cookie-based authentication first
    if cookies.signed[:session_token].present?
      return Session.find_by_id(cookies.signed[:session_token])
    end

    # Try Authorization header authentication
    if request.headers['Authorization'].present?
      token = request.headers['Authorization'].gsub(/Bearer +/, '')
      return Session.find_by_id(token)
    end

    nil
  end

  def check_session_cookie_availability
    # Check if session cookie is available (privacy + iframe mode detection)
    if request.session.id.nil? || !cookies.key?('_clacky_app_session')
      @privacy_iframe_mode = true
      flash.now[:alert] = "Your browser may be in privacy + iframe mode. " \
                          "Login features may not work properly. " \
                          "Please open in a new window using the top-right button."
    else
      @privacy_iframe_mode = false
    end
  end

  def handle_password_errors(user)
    error_messages = []

    user.errors.each do |error|
      case error.attribute
      when :current_password
        error_messages << "Current password is incorrect"
      when :password
        if error.type == :too_short
          error_messages << "New password must be at least #{User::MIN_PASSWORD} characters long"
        elsif error.type == :invalid
          error_messages << "Password format is invalid"
        else
          error_messages << "New password: #{error.message}"
        end
      when :password_confirmation
        error_messages << "Password confirmation doesn't match"
      when :password_digest
        error_messages << "Password format is invalid"
      end
    end

    if error_messages.empty?
      error_messages = user.errors.full_messages
    end

    return error_messages.first
  end

  # Authentication private methods end
end

