class ApplicationController < ActionController::Base
  # Authentication methods generated by authentication generator
  before_action :set_current_request_details
  before_action :restore_validator_context

  helper_method :current_user, :user_signed_in?, :unread_notifications_count
  # Authentication public methods generated end

  # Only allow modern browsers supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has.
  allow_browser versions: :modern

  include FriendlyErrorHandlingConcern
  include DevelopmentCsrfBypassConcern
  include TurboCompatibleRenderConcern


  # Authentication private methods begin
  private

  def current_user
    Current.session&.user
  end

  def user_signed_in?
    current_user.present?
  end

  def unread_notifications_count
    return 0 unless current_user
    current_user.notifications.unread.count
  end

  def authenticate_user!
    if session_record = find_session_record
      Current.session = session_record
    else
      redirect_to sign_in_path
    end
  end

  alias_method :authenticate, :authenticate_user!

  def set_current_request_details
    Current.user_agent = request.user_agent
    Current.ip_address = request.ip

    if session_record = find_session_record
      Current.session = session_record
    else
      # Auto-login default user if no session exists
      auto_login_default_user
    end
  end
  
  # 恢复验证器执行上下文（设置 data_version）
  def restore_validator_context
    return unless user_signed_in?
    
    begin
      # 查找当前用户的活跃验证会话
      execution = ValidatorExecution.active_for_user(current_user.id)
      return unless execution
      
      # 获取 data_version
      data_version = execution.data_version
      return unless data_version
      
      # 设置 PostgreSQL 会话变量（连接级别）
      # 使用 SET SESSION 而非 SET LOCAL，确保整个连接生命周期有效
      # 这样 AI 创建的数据会自动标记为当前验证器版本
      # RLS 策略也会自动过滤查询，只返回基线 + 当前版本的数据
      ActiveRecord::Base.connection.execute("SET SESSION app.data_version = '#{data_version}'")
      
      Rails.logger.debug "[Validator Context] Restored data_version=#{data_version} for user #{current_user.id} (execution #{execution.execution_id})"
    rescue StandardError => e
      Rails.logger.error "[Validator Context] Failed to restore: #{e.message}"
    end
  end

  def auto_login_default_user
    default_email = 'demo@travel01.com'
    default_password = 'password123'
    
    # Find or create default user
    user = User.find_by(email: default_email)
    
    unless user
      user = User.create!(
        email: default_email,
        password: default_password,
        password_confirmation: default_password,
        verified: true
      )
    end
    
    # Create session for default user
    session_record = user.sessions.create!(
      user_agent: Current.user_agent,
      ip_address: Current.ip_address
    )
    
    # Set session cookie
    cookies.signed.permanent[:session_token] = { value: session_record.id, httponly: true, same_site: :lax }
    
    # Set current session
    Current.session = session_record
  rescue => e
    Rails.logger.error "Failed to auto-login default user: #{e.message}"
    nil
  end

  def find_session_record
    # Try cookie-based authentication first
    if cookies.signed[:session_token].present?
      return Session.find_by_id(cookies.signed[:session_token])
    end

    # Try Authorization header authentication
    if request.headers['Authorization'].present?
      token = request.headers['Authorization'].gsub(/Bearer +/, '')
      return Session.find_by_id(token)
    end

    nil
  end

  def check_session_cookie_availability
    # Check if session cookie is available (privacy + iframe mode detection)
    if request.session.id.nil? || !cookies.key?('_clacky_app_session')
      @privacy_iframe_mode = true
      flash.now[:alert] = "Your browser may be in privacy + iframe mode. " \
                          "Login features may not work properly. " \
                          "Please open in a new window using the top-right button."
    else
      @privacy_iframe_mode = false
    end
  end

  def handle_password_errors(user)
    error_messages = []

    user.errors.each do |error|
      case error.attribute
      when :current_password
        error_messages << "Current password is incorrect"
      when :password
        if error.type == :too_short
          error_messages << "New password must be at least #{User::MIN_PASSWORD} characters long"
        elsif error.type == :invalid
          error_messages << "Password format is invalid"
        else
          error_messages << "New password: #{error.message}"
        end
      when :password_confirmation
        error_messages << "Password confirmation doesn't match"
      when :password_digest
        error_messages << "Password format is invalid"
      end
    end

    if error_messages.empty?
      error_messages = user.errors.full_messages
    end

    return error_messages.first
  end

  # Authentication private methods end
end

