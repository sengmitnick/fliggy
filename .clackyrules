### Startup Command:

bin/dev (Do not use `rails s` directly, as it may cause js/css loading issues)

### The project uses the following tech stack:

Ruby on Rails 7.2
Tailwind v3
Figaro
PostgreSQL
Active Storage (Local disk only, NO cloud storage like S3/GCS)
Kaminari
Puma
RSpec
Stimulus + Turbo (Stream response, no Frame tags, no stream_from)
ActionCable( solid_queue, no redis )
FriendlyId

Do not add or remove any components and avoid upgrading or downgrading components.

**When users ask about deployment/architecture/environment setup** ‚Üí Read `docs/project.md`

## What time you should run/stop project

Restarting project is unnecessary because Rails automatically hot-reloads code changes in most cases. Changes to the following explicitly require a restart:
- `config/` directory files (except `config/routes.rb`)
- `Gemfile`
- `config/application.yml`
- `config/appname.txt`

**CRITICAL: If you run `rails g authentication`, `rails g stripe_pay`, or `rails g llm`, you MUST run `touch tmp/restart.txt` at the END after ALL tasks are complete.**

## MANDATORY PROJECT WORKFLOW - FOLLOW EXACTLY IN THIS ORDER

**STOP! Before creating ANY models or controllers, you MUST complete these steps first:**

### Step 1: REQUIRED - Update Application Name and Design System First
**ALWAYS start by updating the application name:** `echo "YourAppName" > config/appname.txt`

**ALWAYS start by updating existing design system variables in `app/assets/stylesheets/application.css`** (using `npm run build:css` to keep it right). DO NOT create any models/controllers before this.

**ALWAYS use HSL colors in application.css and tailwind.config.js**

If there are rgb colors in index.css, make sure to not use them in tailwind.config.js wrapped in hsl functions as this will create wrong colors

CRITICAL: USE SEMANTIC TOKENS FOR COLORS, GRADIENTS, FONTS, ETC. It's important you follow best practices. DO NOT use direct colors like text-white, text-black, bg-white, bg-black, etc. Everything must be themed via the design system defined in the `application.css` and `tailwind.config.js` files!

**NEVER use `@apply group` in CSS** - `group` class should only be added in HTML templates, not in CSS @apply directives.

**USE EXISTING COMPONENTS**: The system has complete .btn-*, .card-*, .alert-*, .badge-*, .form-* classes. Use these instead of creating new ones. See `application.css` header for full list. Custom components go in application.css bottom section. NEVER modify `components.css`.

Pay attention to contrast, color, and typography.

### Step 2: REQUIRED - Develop demo view based Design System and user requirements
Develop a demo view based on the new design system and user requirements, allowing users to quickly see a UI effect. The view should be located at `app/views/shared/demo.html.erb` (Only write body content, The system has already completed route configuration - when there's no home/index.html.erb, the homepage will automatically render this view)

### Step 3: REQUIRED - Testing visit '/'
**ALWAYS run the project, then use `curl http://localhost:<PORT>/` to ensure these is no error**

### Step 4: Then proceed with other features
Only after completing Steps 1-3, you can create other models and controllers.

### Step 5: MANDATORY - Pass ALL tests and Remove Demo Before Task Completion
**CRITICAL: Run `rake test` with tool run_cmds and ensure ALL tests pass before delivering any feature**
- This is NON-NEGOTIABLE - never deliver with failing tests
- Run multiple times until all tests pass (see Testing Requirements section)
- **If you are planning tasks with TodoWrite tool, ALWAYS include "Run rake test and ensure all tests pass" as a specific task item**
- Remove demo page and references after ALL tests pass.


## Some important tips when Developing user authentication/payment/LLM-calling(AI APP) system

**‚ö†Ô∏è BEFORE CREATING ANY MODELS - CHECK THESE GENERATORS FIRST:**

When developing features that require User or Order models, **DO NOT create them manually**. Use these generators instead:

1. **User Authentication System**: Use `rails generate authentication` to generate User model and authentication system
   - **IMPORTANT**: Before running this generator, ensure NO User model exists
   - The generator creates: User model, migration, sessions, authentication logic, and user pages
   - If User model already exists, remove it first to avoid conflicts

2. **Stripe Payment System**: Use `rails generate stripe_pay [--auth]` to generate polymorphic Payment model
   - **CRITICAL**: Generates Payment model (NOT Order) - Payment works with ANY business model via polymorphic association
   - Use `--auth` option to add user association (requires User model exists)
   - **Payment Model Pattern**:
     - Payment = Technical layer (handles Stripe integration, payment status)
     - Order/Subscription/Booking = Business layer (your domain logic)
     - Payment belongs_to :payable (polymorphic) - can attach to any model
   - **Generator creates**: Payment model, controller, service, partial views, admin interface
   - **You MUST create**: Your business model (Order/Subscription/etc), payment views (show.html.erb, success.html.erb)
   - **Example usage**: See `lib/generators/stripe_pay/USAGE` for complete examples

3. **LLM Integration:**: Use `rails generate llm` to generate LLM service infrastructure. Always prefer streaming via ActionCable - use `LlmStreamJob.perform_later(channel_name:, prompt:, system:)` for real-time streaming responses. Auto-configures LLM_BASE_URL, LLM_API_KEY, LLM_MODEL in application.yml. When storing LLM messages, include `LlmMessageValidationConcern` - don't validate role & content yourself.

Do not recreate administrator functionality in User model. Administrator system already exists. Adding admin page low priority.


## Data Packs - Test/Validation Data Management

**CRITICAL: Data Packs Loading Method**
- **ONLY supported command**: `rake validator:reset_baseline`
- **Location**: `app/validators/support/data_packs/v1/` (NOT `db/seeds/`)
- **Purpose**: Store complete validation and test data for different modules
- **Naming**: Use descriptive names like `insurances.rb`, `cruises.rb`, `hotels_all.rb`
- **Pattern**: Use `insert_all` for batch operations, NOT `find_or_create_by!`

**File Structure Template**:
```ruby
# frozen_string_literal: true

# module_name_v1 Êï∞ÊçÆÂåÖ
# Ê®°ÂùóÊèèËø∞
#
# Áî®ÈÄîÔºö
# - ÂäüËÉΩËØ¥Êòé
#
# Âä†ËΩΩÊñπÂºèÔºö
# rake validator:reset_baseline

puts "Ê≠£Âú®Âä†ËΩΩ module_name_v1 Êï∞ÊçÆÂåÖ..."

# Use insert_all for batch operations
ModelName.insert_all([
  { field1: 'value1', field2: 'value2' },
  { field1: 'value3', field2: 'value4' }
])

puts "‚úì Êï∞ÊçÆÂåÖÂä†ËΩΩÂÆåÊàê"
```

**MANDATORY RULES**:
- ‚úÖ ONLY use `rake validator:reset_baseline` to load all data packs
- ‚úÖ Ensure data packs are COMPLETE with all required fields and associations
- ‚úÖ Test data completeness before committing data pack files
- ‚ùå NEVER use `rails runner "load ..."` for data pack loading
- ‚ùå NEVER place test/validation data in `db/seeds/` directory
- ‚ùå NEVER use `find_or_create_by!` for data packs (use `insert_all` instead)
- ‚ùå NEVER mix production seed data with test data

## Validator verify Method Best Practices

**‚ö†Ô∏è CRITICAL: Query Rules in First Assertion**

The FIRST assertion must query orders and establish baseline data for subsequent assertions. Follow these MANDATORY rules:

**1. Query Pattern (MUST follow exactly):**
```ruby
def verify
  # Êñ≠Ë®Ä1: ÂøÖÈ°ªÂàõÂª∫ËÆ¢Âçï / ÂÆåÊàêÊüê‰∏™Âü∫Á°ÄÊìç‰Ωú
  add_assertion "ÂàõÂª∫‰∫ÜËÆ¢Âçï/ÂÆåÊàê‰∫ÜÊìç‰Ωú", weight: 20 do
    # ‚úÖ MUST include: .where(data_version: @data_version)
    # ‚úÖ MUST filter by core business entity (e.g., attraction name, hotel name)
    # ‚ùå NEVER filter by attributes to be validated (e.g., visit_date, room_type)
    all_records = ModelName
      .joins(:associations)
      .includes(:associations)
      .where(associations: { core_entity: @entity_value })  # Filter by entity
      .where(data_version: @data_version)                    # Session isolation
      .order(created_at: :desc)
      .to_a
    
    expect(all_records).not_to be_empty, "Êú™ÊâæÂà∞‰ªª‰ΩïËÆ∞ÂΩï"
    
    # Store in instance variable for subsequent assertions
    @orders = all_records.select { |o| o.meets_basic_criteria? }
    
    # Validate basic requirements (count, existence)
    expect(@orders.size).to be >= expected_count
  end
  
  return if @orders.nil? || @orders.empty?  # Guard clause
  
  # Êñ≠Ë®Ä2-N: Validate specific attributes separately
  add_assertion "Â±ûÊÄßAÊ≠£Á°Æ", weight: 15 do
    @orders.each do |order|
      expect(order.attribute_a).to eq(@expected_a)
    end
  end
end
```

**2. Query Filters - What to Include/Exclude:**

**‚úÖ MUST include in query:**
- `.where(data_version: @data_version)` - Session isolation (MANDATORY)
- Core business entity filters (e.g., `attraction.name`, `hotel.name`, `flight.flight_number`)
- Filters that define the SCOPE of operation (e.g., `user_id`, `booking_type`)

**‚ùå NEVER include in query:**
- Attributes to be validated (e.g., `visit_date`, `room_type`, `seat_class`)
- These should be validated in SEPARATE assertions for better scoring granularity

**Why?** If you filter by `visit_date` in the query and it's wrong, the error will be "Êú™ÊâæÂà∞ËÆ¢Âçï" instead of "Ê∏∏Áé©Êó•ÊúüÈîôËØØ", losing scoring precision.

**3. Assertion Structure and Dependency:**

**Pattern:**
```ruby
# Êñ≠Ë®Ä1: Existence + Count (weight: 20-25%)
# - Query with data_version + core entity filters
# - Store results in @instance_variable
# - Validate count/existence

return if @orders.nil? || @orders.empty?  # Guard clause

# Êñ≠Ë®Ä2: Core Entity Correct (weight: 10-15%)
# - Validate the core entity is correct
# - E.g., attraction name, hotel name, flight number

# Êñ≠Ë®Ä3-N: Specific Attributes (weight: 10-15% each)
# - Each validates ONE specific attribute
# - E.g., visit_date, quantity, price, room_type
# - Use @orders from first assertion

# Êñ≠Ë®ÄN: Business Logic / Optimization (weight: 20-30%)
# - Validate complex logic (e.g., best price selection)
# - This is often the highest-weight assertion
```

**4. Common Patterns:**

**Example 1: Ticket Booking**
```ruby
def verify
  add_assertion "ÂàõÂª∫‰∫Ü2‰∏™ËÆ¢ÂçïÔºàÊàê‰∫∫Á•®+ÂÑøÁ´•Á•®Ôºâ", weight: 20 do
    all_orders = TicketOrder
      .joins(ticket: :attraction)
      .includes(:ticket)
      .where(tickets: { attractions: { name: @attraction_name } })
      .where(data_version: @data_version)
      .order(created_at: :desc)
      .to_a
    
    @ticket_orders = all_orders.select { |o| ['adult', 'child'].include?(o.ticket.ticket_type) }
    expect(@ticket_orders.size).to be >= 2
  end
  
  return if @ticket_orders.nil? || @ticket_orders.empty?
  
  add_assertion "ÊôØÁÇπÊ≠£Á°ÆÔºà#{@attraction_name}Ôºâ", weight: 15 do
    @ticket_orders.each { |o| expect(o.ticket.attraction.name).to eq(@attraction_name) }
  end
  
  add_assertion "Ê∏∏Áé©Êó•ÊúüÊ≠£Á°ÆÔºà#{@visit_date}Ôºâ", weight: 10 do
    @ticket_orders.each { |o| expect(o.visit_date).to eq(@visit_date) }
  end
end
```

**Example 2: Hotel Booking**
```ruby
def verify
  add_assertion "ÂàõÂª∫‰∫ÜÈÖíÂ∫óËÆ¢Âçï", weight: 25 do
    all_orders = HotelOrder
      .joins(:hotel)
      .includes(:room)
      .where(hotels: { name: @hotel_name })
      .where(data_version: @data_version)
      .order(created_at: :desc)
      .to_a
    
    @hotel_orders = all_orders
    expect(@hotel_orders).not_to be_empty
  end
  
  return if @hotel_orders.nil? || @hotel_orders.empty?
  
  add_assertion "ÈÖíÂ∫óÊ≠£Á°ÆÔºà#{@hotel_name}Ôºâ", weight: 15 do
    @hotel_orders.each { |o| expect(o.hotel.name).to eq(@hotel_name) }
  end
  
  add_assertion "ÂÖ•‰ΩèÊó•ÊúüÊ≠£Á°ÆÔºà#{@check_in_date}Ôºâ", weight: 10 do
    @hotel_orders.each { |o| expect(o.check_in_date).to eq(@check_in_date) }
  end
end
```

**5. Error Messages:**

**‚úÖ Good error messages:**
```ruby
expect(order.visit_date).to eq(@visit_date),
  "Ê∏∏Áé©Êó•ÊúüÈîôËØØ„ÄÇÊúüÊúõ: #{@visit_date}ÔºàÂêéÂ§©Ôºâ, ÂÆûÈôÖ: #{order.visit_date}"

expect(@orders.size).to be >= 2,
  "ËÆ¢ÂçïÊï∞Èáè‰∏çË∂≥„ÄÇÊúüÊúõËá≥Â∞ë2‰∏™ËÆ¢ÂçïÔºåÂÆûÈôÖÊâæÂà∞#{@orders.size}‰∏™ËÆ¢Âçï"
```

**‚ùå Bad error messages:**
```ruby
expect(order.visit_date).to eq(@visit_date), "Êó•ÊúüÈîôËØØ"
expect(@orders.size).to be >= 2  # No message at all
```

**6. Weight Distribution Guidelines:**

- **Existence + Count**: 20-25% (first assertion)
- **Core Entity Correct**: 10-15% (e.g., hotel name, attraction name)
- **Basic Attributes**: 10-15% each (e.g., date, quantity, room type)
- **Business Logic**: 20-30% (e.g., price optimization, complex validation)

**Total**: Should sum to 100%

**7. Common Mistakes to Avoid:**

‚ùå **Mistake 1**: Filtering by validation attribute in query
```ruby
# BAD: visit_date in query
all_orders = TicketOrder.where(visit_date: @visit_date, data_version: @data_version)
expect(all_orders).not_to be_empty  # Error: "Êú™ÊâæÂà∞ËÆ¢Âçï" (unhelpful)

# GOOD: visit_date in separate assertion
all_orders = TicketOrder.where(data_version: @data_version)
add_assertion "Ê∏∏Áé©Êó•ÊúüÊ≠£Á°Æ" do
  all_orders.each { |o| expect(o.visit_date).to eq(@visit_date) }  # Error: "Ê∏∏Áé©Êó•ÊúüÈîôËØØ" (helpful)
end
```

‚ùå **Mistake 2**: Forgetting data_version filter
```ruby
# BAD: No data_version filter
all_orders = TicketOrder.where(user_id: @user_id).order(created_at: :desc).limit(10)
# Problem: May pick up orders from other validator sessions

# GOOD: Include data_version
all_orders = TicketOrder.where(user_id: @user_id, data_version: @data_version)
```

‚ùå **Mistake 3**: Not using guard clause
```ruby
# BAD: No guard clause
add_assertion "ÂàõÂª∫‰∫ÜËÆ¢Âçï" do
  @orders = TicketOrder.where(data_version: @data_version)
end
add_assertion "Êó•ÊúüÊ≠£Á°Æ" do
  @orders.each { |o| expect(o.visit_date).to eq(@date) }  # Crashes if @orders is empty
end

# GOOD: Guard clause
add_assertion "ÂàõÂª∫‰∫ÜËÆ¢Âçï" do
  @orders = TicketOrder.where(data_version: @data_version)
end
return if @orders.nil? || @orders.empty?  # Guard
add_assertion "Êó•ÊúüÊ≠£Á°Æ" do
  @orders.each { |o| expect(o.visit_date).to eq(@date) }
end
```

**8. Testing Your Validator:**

After creating/modifying a validator, ALWAYS run:
```bash
rake validator:simulate  # Test all validators
```

If any validator fails, investigate:
1. Check the error message - is it specific enough?
2. Verify data_version filtering is correct
3. Ensure query filters are appropriate (entity filters only, not validation attributes)
4. Confirm assertion dependencies are handled with guard clauses

## Some important tips when coding

**CRITICAL: Demo File Management**
- `app/views/shared/demo.html.erb` is ONLY for early development preview with fake data - NEVER copy its content to home/index.html.erb
- Once ANY real homepage exists (like `app/views/home/index.html.erb`), you MUST delete demo.html.erb immediately
- NEVER reference or link to demo.html.erb in production features - create real pages with real data from database instead
- Demo serves as temporary placeholder until real pages are developed - copying demo code creates incomplete links and fake data issues

Do not generate any fake data that should originally be in the database for users.

Do not write any business logic in the admin backend that should only be for website management and maintenance.

Generate images using this placeholder website: https://images.unsplash.com/ and simultaneously verify accessibility with `curl` if you need static assets.

**ActiveStorage in Seeds**: When creating seed data for models with image attachments, Use unsplash image for pretty UI. Example: `Photo.create!(title: 'Demo', image: { io: URI.open('https://images.unsplash.com/xxx'), filename: 'photo.jpg' })`.

**Image Processing**: Prefer native ActiveStorage variants. If custom processing needed, use `ImageProcessing::Vips` only. Forbidden: MiniMagick, direct Vips::Image.

When installing any new gem or npm packages, always specify a version you are most familiar with and suitable for the project. Do not use the latest version directly.

**ALWAYS prefer `rails generate models` for batch model generation:**
- Syntax: `rails g models product name:string:default=Untitled price:decimal:default=0 + category name:string + tag name:string color:string:default=#000000`
- Separator: `+` splits different models
- Enhanced syntax support:
  - **Default values**: `field:type:default=value` (e.g., `status:string:default=draft`, `count:integer:default=0`)
  - **Serialize**: `field:text:serialize` (only for text/string; json/jsonb auto-handled)
- **Protected names**: Cannot use `user`, `order`, `payment`, etc. (suggests alternatives)
- ‚úÖ **Auto-adds data_version**: Automatically adds `data_version:string:default='0':limit=50` to all business tables (required for RLS)

Use `rails generate model xxx` only when generating a single model (supports same enhanced syntax as above, also auto-adds data_version).

**‚ö†Ô∏è CRITICAL: data_version Field Management**
- ‚úÖ **ALWAYS use `rails g models` or `rails g model`** - Both generators automatically add `data_version:string:default='0':limit=50` to business tables
- ‚úÖ **System tables excluded**: Administrator, Session, AdminOplog, ValidatorExecution, ActiveStorage* tables don't need data_version
- ‚ùå **NEVER manually create migration files for new tables** - ALWAYS use `rails g models` or `rails g model`
- ‚ùå **NEVER use `rails g migration CreateXxx`** - This bypasses data_version auto-generation
- ‚ùå **NEVER add data_version manually** - The generator does it automatically
- üéØ **Why this matters**: All business tables require data_version for multi-tenant data isolation via PostgreSQL Row Level Security

Use `rails generate service xxx` to generate a service file, not generate by yourself.

Use `rails generate admin_crud xxx` (where xxx is your model name that you created before) to create the initial CRUD when developing the admin management page, modify generated code for free.

Use `rails generate controller xxx [action1] [action2] [--auth] [--single]` (where xxx is your controller name, action is optional(all actions by default), --auth means need authenticate_user!, --single generates singular resource without index action) to create controllers when developing the user-side functionality, modify generated code for free.

Use `rails generate channel xxx [action1] [action2] [--auth]` to create ActionCable channels. Generates BOTH xxx_channel.rb (WebSocket) AND xxx_controller.ts (handles BOTH WebSocket AND UI interactions). Don't create separate controllers - extend the generated one. --auth means need current_user and authenticate_user!

Use `rails generate pwa` to generate Progressive Web App setup with manifest, service worker, and install controller. Auto-detects app name from config.x.appname and theme color from application.css --color-primary.

Use `rails generate stimulus_controller xxx` to create new Stimulus controller, not generate by yourself.

**‚ö†Ô∏è TURBO STREAM ARCHITECTURE - Mandatory Rules:**

**What is Turbo Stream?**
- Turbo Stream = Response format (render xxx.turbo_stream.erb) for partial DOM updates
- ‚ùå NOT `turbo_stream_from` in views (we don't use this pattern)
- ‚ùå NOT `<turbo-frame>` tags (we don't use Frame feature)

**Frontend (Stimulus):**
- ‚ö†Ô∏è `fetch()`: Allowed for AJAX-heavy features (payment confirmation, city search, infinite scroll) - use sparingly
- ‚ùå NO `preventDefault() + requestSubmit()` - preventDefault blocks submission
- ‚úÖ Stimulus for UI only (toggle, show/hide) - prefer form submission over fetch

**Backend (Controllers):**
- ‚úÖ Prefer HTML: Render normal HTML views by default
- ‚úÖ Use Turbo Stream when needed: For partial updates, create `action.turbo_stream.erb` templates
- ‚ö†Ô∏è `respond_to` blocks: Allowed for payment/order creation endpoints that need JSON fallback
- ‚ö†Ô∏è `render json:`: Allowed for AJAX endpoints (payment verification, order status, etc.) - use sparingly
- ‚ùå NO `head :ok` - frontend cannot determine UI updates

**ActionCable Channel Pattern:**
- Frontend calls backend: `this.perform('methodName', {params})`
- Backend receives: Define `def methodName(data)` in channel
- Backend broadcasts: `ActionCable.server.broadcast(channel, {type: 'event-name', data: {}})`
- Type-based routing: Frontend defines `handleEventName(data)` method, backend triggers it via `type: 'event-name'`
- ‚ùå NO manual message parsing - the routing happens automatically

**‚ö†Ô∏è STIMULUS TESTING - CRITICAL COMPLIANCE**:
- ALWAYS run `bundle exec rspec spec/javascript/stimulus_validator_spec.rb` after ANY Stimulus-related changes
- ALL stimulus validator errors are REAL errors, NOT false positives - fix them immediately
- NEVER dismiss or ignore stimulus validator failures as "misleading" or "incorrect"
- These tests validate critical controller-view integration - failures mean broken functionality

**‚ö†Ô∏è STIMULUS CONTROLLER & VIEW STYLE SYNCHRONIZATION - CRITICAL**:
- When modifying view templates with Stimulus targets, ALWAYS check corresponding controller logic
- When changing CSS classes in views that are manipulated by controllers, ALWAYS update controller code
- **Pattern to follow**:
  1. If view uses `class="text-gray-900 text-gray-500"` for active/inactive states
  2. Controller MUST manipulate these EXACT classes: `classList.add('text-gray-900')` / `classList.remove('text-gray-500')`
  3. NEVER leave controller manipulating old classes (e.g., `border-blue-500`) when view uses new classes
- **Before modifying view styles**:
  1. Search codebase for the Stimulus target name (e.g., `tabDomestic`)
  2. Check if any controller methods manipulate classes on that target
  3. Update controller logic to match new class names
- **After modifying controller logic**:
  1. Verify view template has the matching CSS classes
  2. Test the interaction in browser to ensure styles change correctly
- **Common failure pattern**: View uses `text-gray-900/text-gray-500`, controller still manipulates `border-blue-500/border-transparent` ‚Üí styles don't change
- **Fix protocol**: Always run `npm run build` after updating TypeScript controllers to regenerate JavaScript bundles

Use FriendlyId (already configured) if need slug URLs. For user-facing content use `friendly_id :title, use: :slugged`, for admin/API use simple IDs.

Every form should include error messages using the shared partial. Add `<%= render 'shared/form_error_message', model: @your_model %>` at the beginning of every form for consistent error display. Never write nested form.

## üéØ FRONTEND DEVELOPMENT RULES - STIMULUS + TURBO + TYPESCRIPT

**MANDATORY**: ALL frontend interactions MUST use Stimulus controllers. NO inline JavaScript allowed.

ALWAYS prefer TailwindCSS v3 and Stimulus controllers for UI behavior. NO pure JavaScript or jQuery allowed.

## Testing Requirements

**MANDATORY**:
- View/Controller changes: `bundle exec rspec spec/requests/xxx_spec.rb` must pass
- Major changes or before delivery: Run full `rake test` to ensure stability

**Testing Order (CRITICAL - Follow this sequence):**
1. **ERB HTML Validation**: Run `bin/validate_erb_html` to check HTML structure validity
2. **Unit/Request Tests**: Run `rake test` to verify backend logic

`rake test` is configured to only show 5 failed test cases at a time, so you should repeatedly run rake test if these have errors (no more than 10 rounds) until all tests pass

For authenticated curl: `rails dev:token[test@example.com]` outputs the token and example curl command (will create user if not exists). Copy the token and use it:
```bash
curl -H 'Authorization: Bearer <token>' http://localhost:<PORT>/your_endpoint
```

Do not use `rails console`, use `rails runner` instead if you want insert or check db data.

Use `bundle exec rspec spec/requests/xxx_spec.rb --format documentation`( not -v or --version ) for single test.

**When you see "Views for xxx are not yet developed" error during testing, immediately create the corresponding view file, then re-run the tests.**

Temporary files should be written in the `tmp` directory.

## ERB HTML Validation

**Purpose**: Validate HTML structure in ERB templates before running other tests.

**Commands**:
- Validate all: `bin/validate_erb_html` or `rake erb:validate`
- Validate single file: `bin/validate_erb_html app/views/xxx.html.erb` or `rake erb:validate_file[app/views/xxx.html.erb]`

**When to use**:
- ALWAYS run before Playwright tests when frontend pages are involved
- After creating or modifying any `.html.erb` files
- Before committing view changes

**What it checks**:
- HTML tag matching (opening/closing tags)
- Proper nesting structure
- Valid HTML5 syntax
- Filters out ERB-specific false positives

See `docs/ERB_HTML_VALIDATION.md` for detailed documentation.

## Debugging Frontend Errors

**Frontend Error Report Protocol:**
1. **Read logs FIRST** - Don't guess, check Run project output and stack traces
2. **Identify root cause** - What action triggered it? What's the actual error?
3. **Minimal fix** - Fix only what's broken based on logs
4. **Test** - Verify the exact scenario that failed

## Code Quality

**FAIL FAST PRINCIPLE:**
- NEVER use default values to hide missing required data
- Let functions return `nil` or raise errors when data is missing
- Validate inputs early and explicitly
- Avoid "silent failures" that mask bugs

**CODE COMMENTS:**
- Minimal comments, focus on self-documenting code
- English only, explain WHY not WHAT
- No obvious comments that repeat the code

## Some files never edit

Never edit `application.html.erb`, `admin/base_controller.rb`, `clipboard_controller.ts`, `dropdown_controller.ts`, `theme_controller.ts`.
